# 8. 数组

* 在前面的几章中，我们介绍了基本数据类型，它们只能针对单个变量进行操作，如果我们要对一组类型相同的数据进行操作，使用基本数据类型是效率很低的。因为假如这一组类型相同的数据有500个，如果使用基本数据类型就需要设置500个变量。C语言提供了一种**构造数据类型：数组**。

* 思考：用姓名区分学生除了不方便，还有其他问题吗？

数组：

* 数组是含有多个数据值的数据结构，并且每个数据值具有相同的数据类型。

  * 其中每一个数据，称为元素
  * 数组的元素可以通过它们在数组中的位置（下标）来一个个地选出来

* 一维数组：

  * 声明：

    * 数组的声明：**类型 数组名[数组长度];**

    * ```c
      int a[20];  //定义了一个最多可以存20个元素的int类型数组a
      float score[8];  //一个最多可以存8个元素的float类型数组score
      char str[5];  //定义了一个最多可以存5个元素的char类型数组str
      ```

    * 数组名的命名规则。（标识符的命名规则）

    * 数组的长度可以用任何（整数）常量表达式指定。**数组一旦定义，长度就固定不变**。

    * 数组名在程序中不能改变。

    * 数组的类型可以是任何基本数据类型。

      * 上面定义的数组中：数组a为整型数组（准确说，是int类型数组），共有10个数组元素，每个元素都能存放一个整数，由于每个数组元素占4个字节（int类型占32个比特，4个字节），因此数组a占40个字节的内存。
      * 以此类推，数组score所占内存为（         ）字节。数组str所占内存为（         ）字节。
        * 32。5。

  * 一维数组的初始化：

    * 像其他变量一样，数组元素在使用之前必须要初始化，即赋予它一个有效的初始值。

      * 第一种方式，是**声明时初始化**（简称初始化式）：即用大括号把所有数值（也可以是常量表达式）括起来，数值之间用逗号进行分隔，数值按排列顺序依次赋值给数组元素。

        ```c
        int a[5] = {1, 20, -3, 48, 5};//初始化式
        char c[3] = {'a', 'b', 97};
        ```

        <img src="/Users/zhangxianyu/c-slides/8数组.assets/shuzu.png" style="zoom: 33%;" />

        * 花括号中数值的数量可以比数组元素的少：

          * 那么前面的元素被逐个赋值，后面的元素以默认值进行赋值：如果是数值型数组，则以0赋值；如果是char类型数组，则以空字符（'\0'）赋值。

          ```c
          int a[5] = {3, 5};//数组a实际被初始化为了{3, 5, 0, 0, 0}
          char c[3] = {'a'};//数组c实际被初始化为了{'a', '\0', '\0'}。注意字符常量的写法：用单引号括起。
          ```

        * 注意：如果花括号中数值的数量超过了数组的长度，程序会在编译中报错。所以请注意检查数组长度和初始化式的长度是否合适。

          ```c
          int a[5] = {1,2,3,4,5,6}; //error!
          ```

        * 在初始化式中（即声明时初始化），也可以省略数组的长度：

          ```c
          int a[] = {1,2,3,4,5,6}; //数组长度为6。数组长度一旦固定，就不能再改变。
          ```

          * 注意：数组长度一旦固定，就不能再改变。

      * 第二种方式：是用for循环遍历数组元素，初始化每一个元素：

        ```c
        int a[10];
        for(i=0; i<sizeof(a)/sizeof(a[0]); i++)
          a[i] = 0;
        //把数组a的每个元素都赋值为0。
        //更简单的方法是使用初始化式：int a[10] = {0};
        ```

      * 注意：如果数组是先定义的，而后才进行初始化，那么就只能通过循环结构来对数组元素逐个进行赋值，不能使用初始化式（第一种方法）。

  * 数组的使用：

    * 可以通过数组的下标（或称索引，index）来方便地存取特定的数组元素。

      * 格式：**数组名[下标]**

      * 如果数组的长度为n，那么数组元素的下标始终从0开始，到n-1为止（总计只能存储n个元素）。

      * ```c
        int a[3];
        a[0] = 1;
        a[1] = 2;
        a[2] = a[0] + a[1]; 
        //此时，数组a中存了3个int类型数，分别是1，2，3。
        ```

    * 所有的数组元素都可以像普通变量一样使用：

      ```c
      a[0] = 1;
      scanf("%d", &a[0]);
      printf("%d\n", a[5]);
      ++a[i];
      ```

    * 下标可以是整型常量、整型变量或整型表达式。如：a[3]，a[i+j*10]，a[i++]等等。

    * 数组名代表数组的首地址，即a[0]的地址，数组名在程序中不能改变。

    * 注意：C语言不会自动检查数组下标是否越界。比如：

      ```c
      int a[3] = {1,2,3};
      a[3] = 5; //这里想访问数组a的第四个元素，下标越界，会导致不可预知的行为。
      ```

  * 一维数组的应用：

    * 从一组数据中找出最大值和最小值（p91）
    * 筛法
    * 查找
      * 折半查找
    * 排序——冒泡排序

* 二维数组：

  * 数组可以有任意维数。
  * 通过下标的数量来确定这个数组是几维数组：
    * `int a[2][3]`是二维数组
    * `int a[2][3][3]`是三维数组
  * 多维数组的应用：
    * 棋盘、矩阵 —— 二维数组
    * 飞机导航，3D游戏 —— 三维数组

  * 声明一个二维数组（数学上称为矩阵）：**类型 数组名[行长度] [列长度]；**

    ```c
    int a[2][4]; //数组a有2行4列
    ```

    * 这个数组有2行4列，即它包含2个元素，每个元素都是一个一维数组（包含4个元素）。
    * （p99，图6-14）

  * 二维数组的元素个数 = 行数 x 列数

  * 二维数组的访问/引用：（p100） 

    * 问：`已知int a[2][3];如果访问数组a的最后一个元素？`

  * 二维数组**初始化式**（声明时初始化）：

    * 方法一：嵌套一维数组的初始化式

      * ```c
        int a[2][3] = {{2, 3, 6},
                       {4, 5, 7}};
        ```

      * 注意：每个一维数组要用花括号括起，每个一维数组之间用逗号隔开。

      * `a[1][1] = ?`

      * `a[2][2] = ?`

    * 方法二：方法一可以简写如下

      * ```c
        int a[2][3] = {2, 3, 6, 4, 5, 7};
        ```

      * 数组会把元素按顺序逐个进行赋值。（一行一行赋值）

    * 方法三：只对部分元素进行赋值

      * ```c
        //只填充前三行，后两行自动初始化为0
        int m[5][9] = {{1, 1, 1, 1, 1, 0, 1, 1, 1},
                       {0, 1, 0, 1, 0, 1, 0, 1, 0},
                       {0, 1, 0, 1, 1, 0, 0, 1, 0}};
        
        //内层初始化式也可以省略，不必全部填满，剩余的元素初始化为0
        int m[5][9] = {{1, 1, 1, 1, 1, 0, 1, 1, 1},
                       {0, 1, 0, 1, },
                       {0, 1, 0, 1, 1, 0, 0, 1},
                       {1},
                       {1, 1, 0, 1, 0, 0, 1, 1, 1}};
        
        //甚至可以省略掉内层的花括号：一旦编译器发现数值足以填满一行，它就开始填充下一行。
        int m[5][9] = {1, 1, 1, 1, 1, 0, 1, 1, 1,
                       0, 1, 0, 1, 0, 1, 0, 1, 0,
                       0, 1, 0, 1, 1, 0, 0, 1, 0,
                       1, 1, 0, 1, 0, 0, 0, 1, 0,
                       1, 1, 0, 1, 0, 0, 1, 1, 1};
        ```

    * 方法四：可以省略数组的行下标

      ```c
      int a[][3] = {1,2,3,4,5,6,7,8,9};
      ```

      * 注意：多维数组，只能省略第一个下标的数值。

  * 二维数组一旦已经定义，则初始化只能通过循环嵌套结构来对数组的每一个元素进行赋值：

    ```c
    int a[3][8],i,j;
    for(i=0;i<3;i++)
      for(j=0;j<8;j++)
        a[i][j] = 1;
    ```

* 数组下标越界：由于 C 语言不会对数组下标取值范围进行严格检查，一旦发现数组上溢或下溢，都会因抛出异常而终止程序。也就是说，C 语言并不检验数组边界，数组的两端都有可能越界，从而使其他变量的数据甚至程序代码被破坏。

  因此，检验数组的边界是程序员的职责。

* 二维数组的应用：
  * 矩阵求和
  * 杨辉三角形

字符数组：

* 定义：`char str[10]`

* **初始化式（声明时初始化）**：

  ```c
  char c[5] = {'c', 'h', 'i', 'n', 'a'};
  char c[] = {'c', 'h', 'i', 'n', 'a'};
  char c[5] = {'c', 'h'}; //剩余元素被赋值为'\0'。(空字符)
  char c[3] = {97, 98, 99};
  ```

* 字符串：

  * 定义：字符串就是用双引号括起来的若干个字符的字符序列。

  * eg：“china”，“a”，“10086”等等，这些是字符串常量（或称字符串字面量）。

  * 存储：C语言把字符串字面量作为**字符数组**来处理。当C语言编译器在程序中遇到长度为n的字符串字面量时，它会为字符串字面量分配长度为n+1的内存空间。这块内存先存储字符串的n个字符，并在结尾加上一个'\0'作为字符串的结束标志。

  * eg：p107，图6-16

  * 结束标志符：'\0'。

  * **使用字符串对字符数组做声明时初始化**：

    ```c
    char str1[10] = {"china"};
    char str2[10] = "china"; //二者等效
    ```

    * 注意：接收字符串的字符数组的长度如果比字符串的长度长，那么剩余部分用空字符赋值；如果短，则会发生未定义行为。（我们可以写一个测试程序）

    * 声明时初始化，数组的长度可以省略。

    * 请问：数组str3的长度是多少？

      ```c
      char str3[] = "my desktop";
      ```

  * 思考：以下二者是等效的吗？

    ```c
    char str[] = {'c', 'h', 'i', 'n', 'a'};
    char str[] = {"china"};
    ```

  * 字符数组的输入输出：从字符数组的初始化式可以看出，我们可以对字符数组的元素使用单个字符来逐个进行赋值，也可以使用字符串一次性对字符数组赋值。

    * 单个字符输入输出：

      ```c
      scanf("%c", &str[0]);
      printf("%c", str[0]);
      ```

    * 使用字符串输入输出：

      ```c
      scanf("%s", str);
      printf("%s", str);
      ```

      * 调用scanf函数时：

        * 数组的前面不需要取地址符&，因为数组名就代表数组第一个元素的地址。
        * scanf读取字符串时，首先会跳过空白字符，然后开始读入字符串，直到遇到任何一个空白字符为止。所以如果用户输入的字符串是 "great china"，那么scanf函数只会读取‘great’ 然后就停止并退出。在读取结束后，数组str会存入great和'\0'。
        * 如果想一次读取一整行字符（包括空白字符），可以使用**gets(字符型数组名)**函数
        * 记住，scanf函数读取的字符串，永远不会包含空白字符。
        * 注意：一定要确保存储字符串的字符数组的长度足够长。如果数组长度比字符串长度短，是非法的。

      * 调用printf函数时：

        * 占位字符%s也可以有更丰富的形式：**%m.ps**

          * m表示最小字段宽度

          * p表示输出字符的个数

          * ```c
            printf("%.4s", "china");//chin
            ```

        * 输出的字符串不会显示'\0'。

        * 如果一个字符串中包含多个'\0'，那么遇到第一个'\0'时输出结束。

    * p108，例6-13

  * 字符串的处理函数：

    * 注意：除了puts()和gets()存储在头文件<stdio.h>中，其余函数都存储在头文件<string.h>中，如果想使用这些函数，则需要引入指令。

    * puts() - 输出

      * 格式：**puts(字符数组名)**

      * 功能：将字符串输出到屏幕

      * 说明：输出时，遇到第一个'\0'就结束，并且在输出结束时自动换行。

      * ```c
        char c[] = {"china\0\0great"};
        puts(c);  //china(换行)
        printf("%d", sizeof(c)); //13
        ```

    * gets() - 输入

      * 格式：**gets(字符数组名)**
      * 功能：从键盘中书一个字符串，并保存到字符数组（结尾自动补'\0'）
      * 说明：gets()函数不会跳过空白字符，而是会一直读，直到遇到'\n'为止。并且会忽略'\n'，而是把'\0'作为结尾存入数组。（一定要注意字符数组的长度是否足够）

    * strlen() - 实际长度

      * 格式：**strlen(字符串)**
      * 功能：计算字符串的实际长度，即第一个'\0'之前的字符的个数。

    * strcat() - 拼接

      * 格式：**strcat(字符数组s1，字符串s2)**

      * 功能：把s2中第一个'\0'及其之前的字符追加到s1第一个'\0'之前，并返回s1（s1会被改变）

        * 参考p110，图6-19
        * 更准确的例子：

        ```c
        #include <stdio.h>
        #include "string.h"
        void main() {
            int i;
            char str[] = "china\0\0\0cc\0\0\0";
            strcat(str,"bbb\0f");
            puts(str);
            for(i = 0; i<sizeof(str)/sizeof(str[0]); i++)
            printf("%d: %c\n", i, str[i]);
        }
        ```

      * 说明：

        * s1有必要是长度足够的字符数组，而不能是字符串常量；而s2则既可以是字符串常量，也可以是长度合适的字符数组。

        * 如果s1的长度不够，结果是不可预测的。

        * ```c
          char str1[6] = "abc";
          strcat(str1, "def");
          //这回导致strcat函数写到了字符数组str1的后面。
          ```

    * strcpy() - 复制

      * 格式：**strcpy(字符数组s1，字符串s2)**

      * 功能：把s2中第一个'\0'及其之前的字符复制到s1中，并返回s1（s1会被改变）

        * 参考p111，图6-20
        * 更准确的例子：

        ```c
        #include <stdio.h>
        #include "string.h"
        void main() {
            int i;
            char str[] = "china\0\0\0cc\0\0\0";
            strcpy(str,"bbb\0f");
            puts(str);
            for(i = 0; i<sizeof(str)/sizeof(str[0]); i++)
            printf("%d: %c\n", i, str[i]);
        }
        ```

      * 说明：执行strcpy()函数时，是把str2的第一个字符，复制给str1的第一个字符，以此类推，直到str2的第一个'\0'，要把这一个'\0'也复制进去，str1其余部分保持不变。

    * strcmp() - 比较

      * 格式：**strcmp(字符串s1，字符串s2)**

      * 功能：比较两个字符串s1和s2，然后根据s1是小于、等于或大于s2，函数返回一个小于、等于、大于0的值。

        通过选择合适的关系运算符（<,>,<=,>=）或判等运算符（==,!=），可以测试s1和s2之间任何可能的关系：

        ```c
        //检测s1是否小于或等于s2:
        if(strcmp(s1, s2) <= 0)
          ...
        ```

      * 说明：strcmp()函数是按照字典方式进行字符串比较的。更准确说，只要满足以下两个条件之一，strcmp()就认为s1是小于s2的：

        * s1与s2的前i个字符一致，但是s1的第i+1个字符小于s2的第i+1个字符。例如，"abd"小于"abe"，"abc"小 于"bcd"。

        * s1的所有字符与s2的字符一致，但是s1比s2短。例如，"abc"小于"abcd"。
        * 实际上，strcmp()函数的核心返回代码是：s1[i] - s2[i]，即返回第一个不匹配字符的差。

        当比较两个字符串中的字符时，strcmp函数会查看字符对应的ascii码值。知道一些关于字符集的知识可以帮助预测strcmp()函数的结果。

        > 关于ASCII字符集的一些重要性质。
        >
        > 1. A~Z、a~z、0~9这几组字符的数值码都是连续的。
        > 2. 所有的大写字母都小于小写字母。(在ASCII码中，65~90的编码表示大写字母，97~122
        >
        > 的编码表示小写字母。)
        >
        > 3. 数字小于字母。(48~57的编码表示数字。)
        > 4. 空格符小于所有打印字符。(ASCII码中空格符的值是32。)

